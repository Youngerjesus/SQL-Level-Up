## 2. 부분범위 처리 활용 

본 절은 테이블 랜덤 엑세스로 인해 인덱스 손익 분기점 한계를 극복할 수 있는 방법 중 하나인 부분 범위 처리 방법에 대해서 소개한다.

이 방법을 활용하면 대량의 데이터에 엑세스를 하고 가져오지만 부분적으로 조금씩 가지고 오기 때문에 응답 속도가 빠르다는 특징이 있다. 

### 2.1 부분 범위 처리 

부분 범위 처리는 DBMS 가 클라이언트에게 데이터를 전송할 때 한번에 모두 전송하는게 아니라 일정량씩 나눠서 전송하는 방법을 말한다. 

전체 결과를 전송하지 않고 추가적인 Fetch Call 이 오면 그때마다 부분적인 결과를 전송하는 방법을 말한다.

OLTP 환경에서 대용량 데이터를 빠르게 전송하는 방법이 여기에 있다. 

예를 들어 마우스를 클릭하면 아래 JAVA 메소드가 실행된다고 가정해보자. SQL 문에 사용할 데이터가 1억건이 있어도 곧바로 화면에 출력된다.

```java
private void execute(Connection con) throws Exception {
    Statement stmt = con.createStatement();
    ResultSet rs = stmt.executeQuery("select name from table"); 
    
    for (int i = 0; i < 100; i++) {
        if (rs.next()) System.out.println(rs.getString())
    }

    rs.close();
    stmt.close();
}
``` 

이 메소드는 다음과 같이 동작한다. 

- 최초 rs.next() 호출 시 Fetch Call 을 통해서 DB 로 부터 데이터를 가지고와서 클라이언트 캐시에 저장한다.

- 이후 rs.next() 를 호출하면 Fetch Call 을 발생시키지 않고 캐시에서 데이터를 읽는다. 

- 캐시에 저장된 모든 데이터를 소진하면 다시 Fetch Call 을 일으켜서 DB 로 부터 다시 데이터를 가지고 온다.

- 100 건을 모두 채우기 전까지 위 과정을 반복한다.


이 메소드의 경우 DBMS 가 데이터를 한번에 전송하지 않고 먼저 일정량을 전송하고 멈추고 다음 Fetch Call 을 받으면 
다시 데이터를 일부 가져와서 멈추는 구조다. 

이처럼 전체 쿼리 결과 집합을 연속적으로 전송하지 않고 사용자의 요청이 있을때마다 전송하는 걸 '부분 범위 처리' 라고 한다. 

데이터를 전송하는 단위는 'Array Size' 인데 이는 클라이언트 프로그램에서 설정하는게 가능하다. 

Statement 객체의 setFetchSize 메소드를 통해서 Array Size 를 설정하는게 가능하다. 

부분 범위 처리할 땐 멈출 수 있어야 한다. 이는 클라이언트와 DB 의 커넥션이 계속해서 유지가 되어야 한다는 의미다.

DB 에 직접 접속하는 경우애는 커넥션을 계속해서 유지해서 부분 처리가 가능하지만 Spring 같은 커넥션 풀을 이용하는 경우에는 단위 작업을 마치면 DB 커넥션을 커넥션풀에 반환해야한다. 따라서 SQL 작업을 나눠서 전송하도록 하는게 어려울 수 있다. 

그렇다면 부분 범위 처리는 의미가 없다고 생각할 수 있지만 그렇지 않다. 이는 뒤에 좀 더 자세하게 설명하겠다. 

#### 정렬 조건이 있을 때 부분 범위 처리 

만약 쿼리문에 order by 절이 있다면 어떻게 될까? 이래도 부분 범위 처리가 될까? 

order by 절이 있다면 데이터베이스는 모든 데이터를 읽고 정렬을 한 후에 부분 처리를 할 것이다.

하지만 order by 절에 해당하는 칼럼이 인덱스로 걸려 있다면 이미 정렬이 되어있기 때문에 모든 데이터를 읽을 필요가 없다. 

### 2.2 OLTP 환경에서의 부분범위 처리에 의한 성능개선 원리 

인덱스와 부분범위 처리 원리를 잘 활용하면 OLTP 환경에서 극적인 성능개선 효과를 누릴 수 있다. 

하지만 여기서 중요한 건 인덱스가 걸려 있지만 정렬을 해야하는 상황에서는 부분 범위 처리가 안되기 때문에 이를 잘 알아두자. 

***

## 배치 I/O

디스크 랜덤 I/O 의 성능을 올리기 위해서 DBMS 는 배치 I/O 기능을 고안했다. 

배치 I/O 는 읽는 블록마다 I/O 를 발생시키는게 아니라 읽을 블록이 일정량 쌓이면 한번에 처리하는 구조다. 

### 배치 I/O 데이터 정렬 이슈

배치 I/O 기능이 작동하면 인덱스를 이용해서 출력하는 데이터 정렬 순서가 좀 다를 수 있다.

인덱스 리프 블록의 물리적 순서와 논리적 순서가 다를 수 있기 떄문에 이는 당연하다.

배치 I/O 를 통해서 테이블에 엑세스 하는 경우에는 실행 계획이 조금 다르다.

기존에는 `TABLE ACCESS BY INDEX ROWID` 가 끝이라면 배치 I/O 를 이용한 방식은 `TABLE ACCESS BY INDEX ROWID BATCHED` 를 통해서 이뤄진다.

인덱스의 소트 연산을 피할 수 없는 경우거나 소트 연산이 필요 없는 경우라면 배치 I/O 를 이용하지 않을 이유가 없다. 

인덱스의 소트 연산을 피할 수 없는 경우는 인덱스 칼럼을 제외한 다른 칼럼 기반의 정렬이 필요한 경우에 사용이 가능하다. 

배치 I/O 를 통해 얻을 수 있는 이점이 많은데도 불구하고 비활성화로 해놓는 경우가 있는데 이는 소트 연산이 필요하지만 인덱스를 사용한 SQL 문에는 ORDER_BY 를 생략한 경우 떄문이다.

정렬 기능이 필요하기 때문에 배치 I/O 가 동작하지 않도록 막아놓는 경우가 있다. 

이제 인덱스 정렬 순서를 믿고 ORDER_BY 를 생략하는 개발 패턴은 별로 좋지않다.  
    

 
  