## 인덱스 설계

***

### 1. 인덱스 설계가 어려운 이유

각각의 SQL 에 맞는 최적의 인덱스를 생성하는 방법은 그렇게 어렵지 않다. 몇 가지 공식만 알고 있으면 되기 떄문이다. 

하지만 그렇게 인덱스를 생성하다 보면 테이블마다 인덱스가 여러개 달리게 되는데 이는 비용이 크다.

인덱스가 많으면 다음과 같은 구체적인 문제가 생긴다.

- DML 성능 저하로 인해 TPS 저하

- 데이터베이스 사이즈 증가

- 데이터베이스 관리 및 운영 비용 상승

예를 들어서 설명하면 테이블에 INSERT 를 할시 인덱스에도 같이 INSERT 를 해야한다. 

인덱스는 각각이 정렬된 상태를 유지해야 하므로 수직적 탐색을 통해 데이터가 들어갈 블록을 찾는다. 근데 들어갈 Leaf Block 에 데이터가 가득 차 있다면 Index Split 도 발생한다. 

Index Split 은 공간이 부족한 경우 새로운 블록을 만들고 그 블록을 기존의 블록과 연결시키는 작업을 말한다. 

데이터를 지울 때도 마찬가지인데 인덱스에서 일일히 레코드를 찾아서 지워줘야 한다.

이렇게 인덱스를 필요할 때 마다 생성하는 식으로 운영하면 비용이 크다. 그리고 인덱스 같은 경우는 운영 환경에서는 바꾸기 힘들다. 바꿀 때 마다 그 테이블에 엑세스 하는 모든 SQL 문을 찾아서 성능 검사를 해야하기 때문이다.

시스템 개발 단계에서는 비교적 인덱스를 변경하기 쉽지만 운영 단계에서는 조금 힘들다. 그나마 신규 인덱스 추가는 기존의 SQL 문에 영향을 미치는 정도가 낮아서 주로 이렇게 해결하곤 하는데 이 방법은 점점 TPS 가 떨어뜨리는 결과를 낳게 된다.

이러한 이유 떄문에 최적의 인덱스 설계가 중요하다. 

***

### 2. 인덱스 설계에서 가장 중요한 두 가지 기준

인덱스를 이용한다는 말은 Index Range Scan 을 사용한다는 말이다.

Index Range Scan 을 사용하기 위해선 SQL 문의 조건절에 인덱스의 선두 칼럼이 포함되어야 한다. 일단은 Index Range Scan 을 이용해야 하고 인덱스를 많이 두지 않기 위해 (하나의 인덱스로 확장시켜나가기 위해) 자주 사용되는 칼럼을 기준으로 인덱스를 선정해야 한다.

두 번째는 인덱스 칼럼을 등치 조건('=') 으로 사용할 수 있어야 하고 이를 앞쪽으로 두어야 한다는 것이다. 이 이유는 이때까지 많이 설명했으므로 넘어가겠다.

***

### 3. 스캔 효율성 이외의 판단 기준

방금 제시한 두 가지 방법은 인덱스 설계의 기본 공식이다. 이 공식의 의의는 인덱스 스캔을 효율적으로 하기 위한 것인데 이것 이외에도 판단해야 할 기준은 많다.

- 수행 빈도

- 업무의 중요도

- 클러스터링 팩터

- 데이터량

- DML 부하

- 저장 공간

- 인덱스 관리 비용 

이런 다양한 판단 기준이 있기 때문에 설계자에 스타일에 따라서 다양한 인덱스가 나올 수 있다. 

이 중 가장 중요한 요소를 꼽자면 수행 빈도가 있다. 자주 수행되지 않는 SQL 이라면 조금 느려도 괜찮다. 종합 비용을 계산하면 많이 수행되는 SQL 문을 효율적으로 만드는게 비용 절감이 가장 크기 때문이다.

이런 자주 수행되는 SQL 문에서 고려할 사항으로 NL 조인에 수행되는 INNER TABLE 에서 사용되는 인덱스다. 

NL 조인에 Outer 쪽 엑세스는 한번만 접근하면 되지만 Inner 쪽은 Outer 에서 집계된 레코드 만큼 반복되기 때문에 자주 수행된다.

예를 들면 다음과 같은 SQL 문이 있다고 생각해보자. 

```sql
SELECT /*+ leading(a) use_nl(b) */ 
b.상품코드, b.상품명, a.고객번호, a.거래일자, a.거래량, a.거래금액
FROM 거래 a, 상품 b
WHERE a.거래구분코드 = 'AC'
AND a.거래일자 between '20090101' and '20090131'
AND b.상품번호 = a.상품번호
AND b.상품분류 = '가전'
```

여기서 A 의 인덱스가 (거래일자 + 거래구분코드로) 이뤄져있다고 생각해보자. 거래 쪽 인덱스는 물론 비효율적인 과정이지만 NL 조인을 하는데 있어서 딱 한번메 그친다.

반대로 다음과 같은 SQL 문을 보자.

```sql
SELECT /*+ leading(b) use_nl(a) */
b.상품코드, b.상품명, a.고객번호, a.거래일자, a.거래량, a.거래금액
FROM 거래 a, 상품 b
WHERE a.거래구분코드 = 'AC'
AND a.거래일자 between '20090101' and '20090131'
AND b.상품번호 = a.상품번호
AND b.상품분류 = '가전'
``` 

여기서는 b 가 Outer 테이블이고 A 가 Inner 테이블로서 역할을 한다. 그리고 인덱스가 (거래일자 + 상품번호 + 거래구분코드) 로 이뤄져있다고 생각해보자. 

그러면 b 에서 a 로 조인을 할 때마다 여러개의 스캔을 해야한다. 되게 비효율적인 과정인데 인덱스가 제대로 (상품번호 + 거래구분코드 + 거래일자) 이렇게 걸려있었다면 훨씬 효율적인 조인을 수행할 것이다.

수행빈도가 높은 SQL 이라면 당장의 성능이 좋게 나오더라도 인덱스를 최대한 효율적으로 구성해주는게 좋다.

데이터량도 인덱스 설계에 중요한 기준이 되는데 일단 데이터량이 적다면 인덱스를 걸 필요가 없다. Table Full Scan 만으로도 충분히 빠르기 때문이다.

초대량인 테이블은 어떻까? 대용량 데이터를 가지고 있다는 사실은 INSERT 가 그만큼 많다는 뜻이고 이런 테이블에는 최적의 인덱스를 걸려고, 인덱스 숫자가 적도록 노력해야한다. 인덱스가 많다면 그만큼 TPS 가 떨어지기 때문에. 

***

### 4. 인덱스 공식을 초월한 전략적 설계

인덱스의 기본 공식 중에는 '=' 조건을 범위 검색 조건보다 앞으로 두는 것이다. 

하지만 상황에 따라서 전략적인 설계가 필요한 경우가 있다. 예시로 보자.

다음과 같은 '가계약' 테이블이 있고 칼럼들이 있다.

```text
<가계약 테이블>

# '=' 조건 칼럼
취급부서
취급지점
취급자
입력자
대리점설계사
대리점지사

# 범위 조건 칼럼
청약일자
보험개시일자
보험종료일자
데이터생성일자
```

요구사항에서 쿼리는 반드시 두 조건을 선택해야 하는데 '=' 조건 칼럼에 있는 취급부서, 취급지점 ... 대리점 지사 중 하나를 골라야 하고 그 다음으로 범위 조건 칼럼 중 하나를 선택해야 한다.  

그러면 우리는 인덱스를 다음과 같이 구성할 것이다. 

```text
# 사용할 인덱스
1. 취급부서 + 청약일자
2. 취급부서 + 보험개시일자
3. 취급부서 + 보험종료일자
4. 취급부서 + 데이터 생성일자

...

21. 대리점지사 + 청약일자
22. 대리점지사 + 보험개시일자
23. 대리점지사 + 보험종료일자
24. 대리점지사 + 데이터 생성일자
``` 
     
이렇게 구성하면 인덱스는 총 24개가 나온다. 이게 과연 합리적일까? 오히려 아래와 같이 설계하는건 어떨까?

```text
# 사용할 인덱스
1. 입력자 + 데이터 생성일자
2. 청약일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리접설계사 + 대리점지사
3. 보험개시일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리접설계사 + 대리점지사
4. 보험종료일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리접설계사 + 대리점지사
5. 데이터생성일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리접설계사 + 대리점지사 
```

이렇게 설계한 핵심 포인트는 딱 두가지다.

- 이 테이블에서 가장 많이 수행되는 빈도는 입력자 + 데이터 생성일자다. 

- 이 테이블에서 범위 검색 조건이 길지 않다면 인덱스 스캔에 미치는 영향은 그렇게 크지 않다. 오히려 테이블 랜덤 엑세스가 미치는 영향이 더 크다라는 점이다. 

즉 그 테이블에 맞는 전략적인 설계가 필요하다는 것이다. 

'가계약' 테이블에서는 주로 최근 3일 이내 데이터를 조회한다. 대게는 전일자로 조회하므로 인덱스 스캔량이 많지 안다는 특징이 있고 어쩌다 한 달 치를 조회하더라도 테이블 풀 스캔 이 발생하지 않고 테이블 랜덤 엑세스도 발생하지 않는다. 그러다보니 사용자가 견디는 수준의 성능은 나올 수 있다는 점이다. 

공식대로 설계하려면 24개의 인덱스가 필요하지만 업무 상황을 고려한 전략적 판단을 이용하면 5개의 인덱스로 끝낼 수 있다. 

***

### 5. 소트 연산을 생략하기 위한 칼럼 추가 

인덱스는 이전에도 말했듯이 항상 정렬된 상태로 유지하므로 ORDER BY, GROUP BY 같은 연산을 생략할 수 있게 해준다.

따라서 조건절에 사용하지 않을 계획이라도 정렬을 위해서 인덱스로 사용하는 것도 가능하다.

아래 쿼리에 ORDER BY 절이 있는데 이게 없어도 정렬이 되도록 하려면 인덱스를 어떻게 고려하면 될까? 

```sql
SELECT 계약ID, 청약일자, 입력자ID, 계약상태코드, 보험시작일자, 보험종료일자
FROM 계약
WHERE 취급지점ID = :trt_brch_id
AND 청약일자 between :sbcp_dt1 and :sbcp_dt2
AND 입력일자 >= trunc(sysdate - 3)
AND 계약상태코드 in (:ctr_stat_cd1, ctr_stat_cd2, ctr_stat_cd3)
ORDER BY 청약일자, 입력자ID
```

성능을 고려하지 않아도 된다면 바로 인덱스는 (청약일자, 입력자 ID) 로 구성할 것이다. 

하지만 이 인덱스에 '=' 조건이 앞에 있던 뒤에있던 청약일자와 입력자 정렬에 영향을 미치지 않는다. 그리고 선두 칼럼에 범위 조건 연산이 있으면 성능이 떨어지는 것도 알고 있다.

그러므로 인덱스를 (취급지점ID, 청약일자, 입력자ID) 이렇게 구성하는게 좋다.

참고로 범위 조건 연산인 경우에는 청약일자와 입력자 뒤에 있는 건 괜찮지만 앞에 있으면 정렬 연산을 생략할 순 없다. 

그렇다고해서 인덱스를 뒤에 막 붙이진 말자. 인덱스를 적절하게 붙이면 테이블 랜덤 엑세스나 인덱스 스캔 효율성을 증가시킬 수 있지만 그냥 막 붙이면 인덱스를 나중에 수정하기가 힘들다. 성능의 요구사항이 생길때 고려하도록 하자.

***  

### 6. 결합 인덱스 선택도

인덱스 생성 여부를 따질 땐 `선택도가 충분히 낮은지가 중요한 판단 기준이다.` 

선택도란 전체 레코드 중에서 조건절로 검색했을때 선택되는 레코드의 비율을 말한다. 즉 선택도가 높다 라는 말은 테이블에서 흔하게 볼 수 있다는 뜻이다. 

그리고 선택도에 총 레코드 수를 곱하면 카디널리티가 나온다.

인덱스 선택도는 인덱스 칼럼을 모두 '=' 로 검색을 했을 때 나오는 비율을 말한다.
  
선택도가 낮은 걸 골라야 하는 이유는 선택도가 높으면 테이블에서 흔하게 볼 수 있으므로 그냥 풀 스캔 하는게 더 나을 수 있고 인덱스에서 테이블 엑세스가 많아지기 때문이다.

#### 칼럼 순서 선택시 선택도 이슈

흔히 잘못 알고 있는 상식으로 선택도가 낮을 수록 결합 인덱스에서 앞으로 나오는게 좋다고 알고있는 경우가 있는데 인덱스에서 레코드를 탐색의 비용은 같다. 

예로 성별과 고객번호 같은 '=' 칼럼이 결합 인덱스로 묶여 있는 경우 한 특정 고객을 찾는 비용은 동일하다. 

인덱스를 설계할 때 고려해야하는 이슈는 자주 사용하는 칼럼과 '=' 으로 사용하는 칼럼을 앞으로 두는 일이다.

다만 주의할 점은 이들이 어떻게 정렬될 것인지 생각하고 설계하는게 좋다. 아무래도 각 정렬이 왼쪽 칼럼대로 정렬되어 있을 것이니 하나의 칼럼만 인덱스 엑세스에 사용한다면 Index Range Scan, Index Skip Scan 을 각각 어느 칼럼에서 사용할것인지 생각을 해야한다.

***

### 7. 중복 인덱스 제거

인덱스 중복은 '완벽중복' 과 '불완전중복' 이 있는데 이러한 중복들을 하나로 합쳐서 인덱스 개수를 줄이는 방법이 있다.

일단 먼저 쉬운 '완벽중복' 부터 보자.

```text
INDEX_01: 계약ID + 청약일자
INDEX_02: 계약ID + 청약일자 + 보험개시일자
INDEX_03: 계약ID + 청약일자 + 보험개시일자 + 보험종료일자
```  

인덱스 완벽중복은 해결하기 쉽자. INDEX_03 만 남겨놓고 나머지는 삭제하면 된다. 

다음으로 인덱스 불완벽중복을 보자. 여러가지 예시를 볼 것이므로 하나씩 소개하겠다.

```text
INDEX_01: 계약ID + 청약일자
INDEX_02: 계약ID + 보험개시일자
INDEX_03: 계약ID + 보험종료일자
INDEX_04: 계약ID + 데이터생성일시
```

모두 선두 칼럼이 계약ID 이다. 만약에 계약ID 의 카디널리티가 5 정도로 매우 낮다면 (전체 레코드중 검색에서 5개만 조회되는 값) 각각의 INDEX 는 모두 5번 정도만 탐색하면 되므로 그렇게 부담이 크지 않다.

그러므로 하나의 인덱스로 (계약ID, 청약일자, 보험개시일자, 보험종료일자, 데이터생성일자) 로 합쳐도 된다. 

불완전중복은 서로의 인덱스가 탐색량이 그렇게 차이가 나지 않는다면 하나로 합치는 방식을 주로 사용한다. 인덱스를 이렇게 합칠 때는 인덱스가 많을 때의 장점인 최적의 쿼리는 삭제 된다는 점을 항상 명심해두자. 그게 없어져도 다른 INDEX 에서 커버가 되는지를 늘 생각하고 중복을 제거하자.

다음 인덱스 불완전중복 예시를 보자.

```text
PK: 거래일자 + 관리지점번호 + 일련번호 
INDEX_01: 계좌번호 + 거래일자 
INDEX_02: 결제인자 + 관리지점번호
INDEX_03: 거래일자 + 중복코드
INDEX_04: 거래일자 + 계좌번호  
```

여기서 거래일자와 결제 인자는 항상 범위 검색 조건으로 쓰인다.

여기서 인덱스 중복을 찾는 방법은 3번과 4번 인덱스가 동일한 선두 칼럼을 사용한다는 것이다. 4번을 3번으로 합쳐서 인덱스를 (거래일자 + 중복코드 + 계좌번호) 이렇게 합쳐도 기존의 인덱스인 (거래일자 + 계좌번호) 랑 그렇게 스캔의 차이가 없다고 생각되면 하나로 합칠 수 있다.

또 계좌번호 위주로 검색을 한다고 생각이 들면 2번이 있으므로 그냥 4번 인덱스를 삭제하는 방법도 있다.

좀 더 인덱스를 수정한다고 하면 PK 같은 경우는 관리자점번호나 일련번호를 선두 칼럼으로 바꾸는 것도 좋을 것 같다. 아무래도 거래일자가 선두 칼럼인 경우는 있으니까.

마지막으로 예시를 하나 더 보자.

```text
PK: 주소 ID + 건물동번호 + 건물호번호 + 관리번호
INDEX_01: 상태구분코드 + 관리번호
INDEX_02: 관리번호
INDEX_03: 주소 ID + 관리번호 
``` 

여기서 상태구분코드가 선택도가 매우 높다라고 가정해보자. 그러면 상태구분코드만 사용할 땐 인덱스를 사용하지 않고 테이블 스캔을 사용할 확률이 높다는 뜻이다.

이 말은 1번 인덱스를 사용하기 위해선 상태구분코드와 관리번호를 같이 사용해야한다는 뜻인데 관리번호는 2번 인덱스로 혼자서 사용이 가능하다.

그러므노 1번과 2번을 합쳐서 인덱스를 (관리번호 + 상태구분코드) 이렇게 바꾸는 것이 괜찮을 것이다. 항상 이렇게 바꿀 때 주의할 점은 1번 쿼리의 최적의 경우를 없애는 경우를 말한다. 

***

### 8. 인덱스 설계도 작성

앞에서도 얘기했듯이 인덱스 설계 시 시스템 전체의 효율을 계산해야한다. 

인덱스 설계에세 전체의 효율을 계산하기 위해 고려해야 할 사항은 다음과 같다.

- 변경 전 인덱스 목록과 변경 후 인덱스 목록 리스트

- 테이블별로 실제 엑세스 하는 유형을 모두 조사 (어떤 칼럼을 이 SQL 에서 사용하는지 포함해서)

- 변경 전과 변경 후 테이블 엑세스 경로를 모두 표현

 



 

