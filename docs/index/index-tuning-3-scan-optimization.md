## 인덱스 스캔 효율화 

***

IOT,  클러스터, 파티션 등은 테이블 랜덤 엑세스를 최소화 하는데 매우 유용하지만 실제 운영환경에서 이를 적용하기엔 성능 테스트 할 요소가 많다.

그래서 실질적으로 튜닝하는 기법은 인덱스 칼럼을 추가하는 등의 방법이 기본적으로 적용된다. 

반면 지금부터 소개할 인덱스 튜닝 기법은 튜닝 요소가 매우 다양해서 흥미를 이끌만한 요소가 많다. 이를 한번 알아보자. 


***

### 1. 인덱스 스캔 효율

일단 이후에 나올 용어에 대해서 먼저 정리해보겠다. 

선두 칼럼과 선행 칼럼이 있는데 선두 칼럼은 가장 앞쪽에 있는 칼럼을 말하고 선행 칼럼은 결합 인덱스에서 상대적으로 앞쪽에, 왼쪽에 있는 칼럼을 말한다. 

좀 더 이해를 위해서 예시를 들겠다. 

다음과 같은 용어 사전이 있다고 생각해보자. 인덱스는 총 4개가 걸려있고 각각의 글자가 인덱스로 이뤄져있다.

```text
성 | 능 | 감 | 시

성 | 능 | 개 | 량

성 | 능 | 개 | 선

성 | 능 | 검 | 사

성 | 능 | 검 | 증

성 | 능 | 계 | 수

성 | 능 | 계 | 측

성 | 능 | 곡 | 선

성 | 능 | 관 | 리

성 | 능 | 시 | 험

성 | 능 | 이 | 론

성 | 능 | 지 | 수

성 | 능 | 측 | 정

성 | 능 | 튜 | 닝

성 | 능 | 평 | 가

성 | 능 | 호 | 환
```  

다음과 같은 질문이 있다고 했을 때 인덱스 스캔 탐색은 어떻게 되는가? 

- 질문1: 이 테이블에서 '성|능|검' 으로 시작하는 레코드를 검색하려면 어디서 스캔하고 어디서 멈출까?

- 질문2: '성|능' 으로 시작하고 네 번째 칼럼이 '선' 인 레코드를 검색하려면 어디서 스캔을 하고 어디서 멈출까?

질문 1 같은 경우는 읻덱스 수직적 탐색을 통해서 시작지점을 바로 찾을 수 있다. 그래서 성능검 부터 시작하는 단어를 찾을 수 있고
스캔의 범위는 두 건만 조회를 하면 된다.

질문 2 같은 경우는 '성능' 으로 시작하는 모든 범위를 탐색한다. 인덱스 수직적 탐색에서 내려와서 가장 왼쪽부터 시작해서 수평적 탐색으로 모든 데이터를 검색하면서 테이블에 엑세스할 데이터를 필터하는 역할을 한다. 

즉 필요한 데이터는 '성능개선' 과 '성능곡선' 이렇게 두 개가 필요하지만 필요하지 않은 데이터를 스캔을 했다. 

왜 이런걸까? `바로 선행칼럼의 조건절이 없거나 이런 조건절이 있어도 '=' 조건이 아니기 때문이다.` ('>' 같은 조건절이라면 이 조건의 시작지점 부터와서 필터를 할 것이므로)

#### 인덱스 스캔 효율성 측정

인덱스 스캔의 효율성을 측정한다는 말은 인덱스 스캔의 탐색한 블록의 수에 비례해서 결과가 몇 개 인지를 나타내는 것인데 SQL 트레이스틑 통해서 볼 수 있다.

결과는 다음과 같이 실행계획처럼 볼 수 있다. 

```text
Rows Row Source Operation
10   TABLE ACCESS BY INDEX ROWID BIG_TABLE (cr=7471 pr=1466 pw=0 time=22137 us)
10     INDEX RANGE SCAN BIG_TABLE_IDX (cr=7463 pr=1466 pw=0 time=22328 us)
``` 

이 말은 결과를 10 개 가지고 오는데 인덱스 블록은 7463 개 읽었다는 사실을 알 수 있다. 

하나의 인덱스 블록에 500 개의 레코드가 있다고 가정해보면 3,731,500 개의 레코드를 읽었고 그 중에서 10개를 얻었다는 말이다.

엄청난 비효율이 발생한 걸 알 수 있다. 

***

### 2. 엑세스 조건과 필터 조건

인덱스 스캔의 효율성을 계속해서 설명하기에 앞서서 반드시 알아야 할 용어가 두 가지가 있다.

'엑세스 조건' 과 '필터 조건'

엑세스 조건은 인덱스 수직적 탐색을 통해서 인덱스 스캔을 시작할 지점과 수평적 탐색을 통해서 인덱스 스캔이 끝날 지점을 결정하는 걸 말한다.

필터 조건은 수평적 탐색을 통한 레코드에서 실제 테이블에 엑세스할지 여부를 말한다. 즉 핕터 조건을 통해서 최종 결과 집합에 포함될지를 결정한다. 

옵티마이저는 이런 조건들을 이용해서 비용을 계산한다. `비용 = 인덱스 수직적 탐색 비용 + 인덱스 수평적 탐색 비용 + 테이블 랜덤 엑세스 비용`

***

### 3. 비교 연산자 종류와 칼럼 순서에 따른 군집성

테이블과 달리 인덱스는 인덱스에 따라서 정렬되어 있으므로 '같은 값' 을 가지는 레코드들이 군집되어 있다.

같은 값을 찾을 때 '=' 연산자를 통해서 조회를 누락없이 하면 조건절을 만족하는 모든 레코드들이 모여있는 걸 알 수 있다.

하지만 이 중 하나를 누락하거나 '=' 이 아닌 조건절을 사용하면 레코드들이 서로 흩어진 상태가 된다. 

다음과 같은 예가 있다고 생각해보자. 리프 블록에는 다음과 같이 들어가 있다.

```text
# Leaf Block 1 
1 A 가 a
1 A 가 a
1 A 가 c
1 A 나 a

# Leaf Block 2
1 A 나 a
1 A 나 a
1 A 나 b
1 A 나 b
1 A 나 c

# Leaf Block 3
1 A 다 a
1 A 다 c
1 B 가 b
1 B 나 a
1 B 나 b

# Leaf Block 4
1 B 다 b
2 A 가 b 
2 A 나 a
2 A 다 c
```

아래 조건절과 같이 인덱스를 사용한다면 조건을 만족하는 레코드들은 모두 모여있다.

```sql
WHERE c1 = '1'
and c2 = 'A'
and c3 = '나'
and c4 = 'a'
```

아래 조건절 처럼 선행 칼럼은 모두 '=' 이고 맨 마지막 칼럼의 범위만 '부등호, Between, LIKE' 같은 조건이라도 모두 레코드들이 모여있다.

```sql
WHERE c1 = '1'
and c2 = 'A'
and c3 = '나'
and c4 >= 'a'
``` 

하지만 맨 마지막 칼럼이 아닌 중간 칼럼이 범위 검색 조건이라면 흩어지게 된다.

```sql
WHERE c1 = '1'
and c2 = 'A'
and c3 between '가' and '다'
and c4 = 'a'
```

또 맨 첫번째 칼럼이 범위 검색 조건이라면 흩어지게 된다. 

```sql
WHERE c1 between 1 and 3
and c2 = 'A'
and c3 = '나'
and c4 = 'a'
```  

여기서 발견할 수 있는 규칙은 선행 칼럼이 모두 '=' 이고 이후에 범위 연산 기호가 나오면 그때까지만 데이터들은 모여있다는 것이다.

범위 연산 다음에 있는 조건들의 경우에 레코드들은 모두 흩어지게 된다. 그래서 맨 마지막에 범위 연산이 있는 경우라면 상관이 없다. 

사실 범위 조건 연산 다음에 있는 칼럼도 인덱스 스캔량을 줄이는데 어느정도 기여를 하긴한다. 수직적 탐색에서 줄이는데 기여를 하겠지만 그렇게 크진 않다.

범위 조건 연산이 뭐가 있는지 더 알아보자면 다음과 같다. 

- 좌변 칼럼을 가공한 조건절

- 왼쪽과 오른쪽 모두 '%' 가 있는 LIKE 조건절

- 같은 칼럼에 대한 조건절이 두 개 이상이라서 인덱스 엑세스 조건으로 사용하지 못하는 경우

- OR Expansion 또는 INLIST ITERATOR 로 선택되지 못한 OR 조건 또는 IN 조건

***

### 4. 인덱스 선행 칼럼이 등치(=) 조건이 아닐 때 생기는 비효율 

인덱스 스캔의 효율성은 인덱스 선행 칼럼이 모두 '=' 조건일 때가 가장 좋다. 

필터 조건이 없으므로 스캔으로 찾은 모든 데이터가 테이블 엑세스로 이어질 수 있기 때문이다.

그리고 인덱스의 맨 마지막 칼럼이 범위 검색 조건이라도 괜찮다. 그래도 인덱스 수평적 탐색으로 찾은 거의 모든 데이터가 테이블 엑세스로 이어질 수 있기 떄문이다.

하지만 중간 칼럼이나 선두 칼럼이 범위 검색 조건이면 인덱스 스캔에서 비효율이 발생한다. 인덱스 스캔의 시작지점이 다양할 수 있고 그 과정에서 필터의 연산이 집중되기 떄문에 실제 조회되는 데이터는 별로 없지만 스캔은 많이하는 경우가 발생할 수 있기 떄문이다. 

이를 통해 알 수 있는 점은 인덱스의 칼럼을 정할 때 '=' 조건을 사용할 수 있는 칼럼을 선두나 선행 칼럼으로 사용하는게 좋다. 

***

### 5. Between 을 IN LIST 로 전환

범위 검색 칼럼을 뒤로 두는게 좋다는 사실을 알았지만 운영 환경에서는 이런 인덱스 구조 자체를 바꾸는 건 어렵다. 

그러므로 주어진 인덱스 구성 안에서 최대한 성능을 내도록 튜닝을 해야하는데 선행 칼럼이 Between 같은 범위 검색 칼럼으로 구성되어 있다면 이를 IN-List 로 바꿔주면 효과가 있을 수 있다. 

IN-List 로 바꾸면 인덱스 수직적 탐색을 여러번(ITERATOR) 한다는 뜻으로 실행 계획을 보면 다음과 같다. 

```text
SELECT STATEMENT 
    INLIST ITERATOR
        TABLE ACCESS BY INDEX ROWID
            INDEX RANGE SCAN
```  

dbms_xplan.display_cursor 함수를 이용해 Row Source 수행 통계를 직접보면 Starts 칼럼을 통해 해당 실행계획을 몇번 하는지 볼 수 있다. 

인덱스를 여러 번 탐색한다는 것은 각 SQL 문을 UNION ALL 을 통해 합친다는 말과 동일하다. 

IN LIST 개수 만큼 UNION ALL 을 생성하고 모든 칼럼을 Between 이 아닌 '=' 조건으로 실행 한다는 말과 동일하다.

이 방식은 잠시 후에 설명할 Index Skip Scan 방식과 유사할 수 있다. 

이 방식을 이용할 때 주의점은 IN-LIST 의 개수가 적어야 한다는 것이다. 많다면 그만큼 수직적 탐색을 많이 한다는 뜻인데 그러면 오히려 Between 탐색이 더 나을수도 있다. 

그러므로 IN-LIST 가 Between 보다 효율적인지는 비교를 해야 하는데 해당 인덱스에 스캔 방식이 어떻게 되고, 몇개의 레코드를 읽는지 측정을 하면서 이게 얼만큼 개선이 되는지를 알아야 이 튜닝을 제대로 사용하는게 가능할 것 같다.

즉 IN-LIST 방식은 수평적 탐색의 레코드들이 멀리 떨어져 있는 경우에 유용하다는 점이다. 붙어 있는 레코드의 경우에는 Between 이 더 유용할 수 있다.   

IN-LIST 의 개수가 많다면 서브쿼리를 이용하거나 NL 조인을 이용하는 방식으로 '=' 을 활용하는 방법이 있는데 이는 이후에 NL 조인을 설명할 때 이야기하겠다. 

SQL 문은 다음과 같은 식으로 해결팔 수 있다.    
 
```sql
SELECT b.해당층 b.평당가, b.입력일, b.해당동, b.매몰구분, b.연사용일수, b.중개업소코드
FROM 통합코드 a, 매몰아파트매매 b 
WHERE a.코드구분 = 'CD064' -- 인터넷 매몰 구분 
AND a.코드 between 1 and 3
AND b.인터넷매물 = a.코드
AND b.아파트시세코드 = `A0133111455`
AND b.평형 = '59'
AND b.평형타입 = 'A'
order by b.입력일 desc
```

***

### 6. Index Skip Scan 의 활용

Between 절을 IN-List 로 만들지 않고도 Index Skip Scan 을 이용해 개선하는 방법도 있다. 

Index Skip Scan 의 활용은 IN-List 와 동일하다. 수평적 탐색으로 스캔하는 대상이 군집화되어 있지 않고 띄엄띄엄 존재한다면 효과가 클 수 있는 방법이다.

Index Skip Scan 을 하기 위해선 SQL 문에서 `/** INDEX_SS */` 과 같은 힌트를 주면 사용할 수 있다.

***

### 7. IN 조건은 '=' 인가? 

SQL 튜닝 입문자들은 주로 IN 조건을 '=' 과 동일시 한다는 특징이 있다.

우리가 이전까지 Between 을 IN-List 로 튜닝할 때 사용한 IN 은 '=' 조건이 맞다. 그게 효율적인 경우를 봤던 것이고.

하지만 IN 을 이처럼 테이블 엑세스 조건으로 보는게 아니라 필터 조건으로 사용되면 좋은 경우도 있다. 

인덱스가 (상품 ID + 고객번호)로 이뤄진 경우와 (고객번호 + 상풍 ID) 를 비교해보자. 

상품 ID 를 IN 조건을 통해 (NH0037, NH0041, NH0099) 이렇게 있다고 헀을때 (상품 ID + 고객번호) 로 이뤄진 인덱스의 경우에는 IN-LIST 로 풀리는게 좋다.

하지만 인덱스가 (고객번호 + 상품 ID) 로 이뤄져있다면 필터 형식으로 동작하는게 더 낫다. 고객번호를 기준으로 상품 ID 가 정렬되어 있을 것이므로 

그러므로 인덱스에서 IN 을 사용할 때 주의할 점은 IN-LIST ITERATOR 로 풀 것인지 필터로 풀 것인지를 정해야 한다. 

이 말은 인덱스를 테이블 엑세스에 사용할 것인지 말 것인지와 똑같은 말이다. 인덱스를 테이블 엑세스에 사용한다는 것이 IN-LIST 로 사용한다는 의미이기 떄문에.

인덱스를 필터로 사용하면 실행계획은 다음과 같이 나온다. 

```text
# 인덱스는 상품_X01 로 (상품 ID, 상품구분코드) 로 이뤄져있다. 

Execution Plan
----------------------------------------------------------
SELECT STATEMENT 
    TABLE ACCESS BY INDEX ROWID
        INDEX (RANGE SCAN) OF '상풍_X01'

Predicate Information (identified by operation id):
----------------------------------------------------------
2 - access ("상품 ID"=:PROD_ID)
2 - filter ("상품구분코드"='GX' OR "상품구분코드"='KR') 
```  

#### NUM_INDEX_KEYS 힌트 사용 

인덱스를 필터로만 사용할거면 테이블 엑세스 조건으로 사용하면 안되므로 이를 위해서는 칼럼을 가공하는 방법과 SQL 힌트를 주는 방법이 있다.

다음과 같이 num_index_keys 함수를 통해 힌트를 주면 된다. 

```sql
SELECT /*+ num_index_keys(a 고객별가입상품_X1 1) */ 
FROM 고객별가입상품 a 
... 
```
세번째 인자인 1을 통해서 테이블 엑세스에 사용할 인덱스 칼럼은 첫번째만 사용하겠다로 적용할 수 있다. 

***

### 8. Between 과 LIKE 스캔 범위 비교 

월별로 집계된 테이블에서 데이터를 2009년 1월부터 2009년 12월 까지 조회한다고 해보자. 

SQL 문은 크게 LIKE 를 이용하는 문과 Between 을 이용하는 문 이렇게 있을 것이다. 에시는 다음과 같다. 

```sql
SELECT * FROM 월별고객별판매집계
WHERE 판매월 LIKE '2009%'
```

```sql
SELECT * FROM 월별고객별판매집계
WHERE 판매월 BETWEEN '200901' and '200912'
```

LIKE 와 Between 은 둘 다 범위 검색 조건으로 사용하는게 가능하다. 

결론부터 말하자면 둘 다 사용하는게 가능할 땐 Between 을 사용하는게 더 낫다. 왜냐하면 Between 은 시작지점과 끝나는 지점을 명시적으로 지정하는게 가능하지만 LIKE 는 그렇지 않기 때문에 스캔의 범위가 조금 더 넓다. 

예를 들어서 인덱스가 (판매월 + 판매구분) 으로 되어있다고 해보자. 판매 구분으로는 'A' 와 'B' 가 있다. 

SQL 문은 다음과 같이 LIKE 를 사용하는 구문과 Between 을 사용하는 구문이 있다. 

```sql
WHERE 판매월 BETWEEN '200901' and '200912'
and 판매구분 = 'B'
``` 
 
```sql
WHERE 판매월 LIKE '2009%'
and 판매구분 = 'B'
``` 
Between 절은 200901 과 B 로 시작하는 지점부터 스캔을해서 200912 와 B 가 모두 끝나는 점까지 스캔을 한다. 

LIKE 절은 200900 도 있을 수 있으니까 200901 의 시작지점 200901 A 로 시작하는 지점부터 시작할 수 있고 끝나는 지점은 200912 와 B 로 같을 수 있다. 

이렇게 LIKE 절은 시작 지점과 끝나는 지점을 명시적으로 알 지 못하니까 추가적인 스캔을 할 수 있다. 

***

### 9. 범위 검색 조건을 남용할 때 생기는 비효율 

사용자의 입력에 따라서 SQL 조건절이 다양하게 변해야 하는 경우에 SQL 을 간편하게 짜기 위해서 범위 검색 조건절을 남용하는 경우가 있다.

이렇게 하면 코드의 재사용성을 높일 순 있지만 인덱스와 관련된 칼럼인 경우 불필요한 인덱스 스캔이 생길 수 있다는 걸 알아두자. 

예를 등어 인덱스가 (회사코드, 지역코드, 상품명) 으로 이뤄져있다. 

사용자의 입력에 회사코드는 반드시 입력하지만 지역 코드는 입력하지 않을 수 있다. 그리고 상품명은 일부만 입력하는게 가능하다. 

이런 조건이 있을 때 나오는 코드는 지역코드의 여부에 따라서 두개가 생길 수 있다. 

```sql
SELECT 고객ID, 상품명, 지역코드
FROM 가입상품
WHERE 회사코드 = :com 
AND 지역코드 = :reg 
AND 상품명 LIKE :prod || '%'
```  
```sql
SELECT 고객ID, 상품명, 지역코드
FROM 가입상품
WHERE 회사코드 = :com 
AND 상품명 LIKE :prod || '%'
```  

하지만 이 두가지 상황을 하나의 SQL 문으로 처리하기 위해서 다음과 같이 작성했다고 생각해보자. 

```sql
SELECT 고객ID, 상품명, 지역코드
FROM 가입상품
WHERE 회사코드 = :com 
AND 지역코드 LIKE :reg || '%'
AND 상품명 LIKE :prod || '%'
```  

이 경우에 생기는 문제점은 사용자가 지역 코드를 입력을 해도 모든 지역코드의 범위를 탐색한다는 문제점이 있다. 

범위 대상을 줄이지 못하는 문제점이 있다. 

LIKE 뿐 아니라 모든 조건절에 Between 을 사용해서 하나의 SQL 문으로 처리하는 경우도 있는데 이도 문제다.   
 
***

### 10. 다양한 옵션 조건 처리 방식의 장단점 비교 

방금 살펴본 방식 외에도 개발자들은 다양한 방식으로 쿼리를 재사용할려고 하는데 이를 알아보자. 

#### OR 조건 활용 

다음과 같은 OR 조건을 사용하는 SQL 문이 있다고 생각해보자. 

```sql
SELECT * FROM 거래
WHERE (:cust_id is null) or 고객ID = :cust_id
AND 거래일자 between :dt1 and :dt2
```

고객 ID 를 인덱스로 사용하고 있고 이것이 선두 칼럼이라면 OR 절에선 이를 인덱스 조건으로 사용할 수 없다. 

인덱스 선두 칼럼을 OR 절로 사용하지 않도록 주의하자. 

OR 절을 사용할 때는 다음과 같은 점을 고려하자. 

- 인덱스 엑세스 조건으로 사용하지 않기 

- 인덱서 칼럼이 Null 이 가능한 경우에 테이블 엑세스에 필터로서 사용하지 않기 

- 인덱스에서 사용하지 않는 칼럼을 테이블 엑세스 필터로 사용하기  

#### LIKE / Between 조건 활용 

앞에서 LIKE 와 Between 같은 범위 조건에 대해서 많이 이야기 했다. 

다음과 같은 점만 주의하자. 

- 인덱스 선두 칼럼으로 사용하지 않기

- NULL 허용 칼럼에 대해서 LIKE 와 Between 사용하지 않기 (LIKE 와 Between 값에 NULL 이 들어가면 공집합이 나오므로.)

- 숫자형 칼럼에 LIKE 를 사용하지 않기 (숫자형 칼럼을 LIKE 로 사용하면 자동 형변환이 일어나서 사용이 되므로 엑세스 조건으로 사용이 안되고 필터 조건으로 사용이 될 수도 있어서.)

- LIKE 는 가변길이도 검색이 된다는 점 알기 (길이까지 비교를 하던가 아니면 '%' 없이 검색을 하도록 하는게 좋다. % 가 없는 경우에 NULL 값이 들어오면 또 공집합이 되므로 NULL 인 경우에 '%' 만 사용해서 검색하도록 해야한다.)

#### UNION ALL 활용

UNION ALL 을 이용해서 특정 변수가 NULL 인지의 여부에 따라서 최적의 SQL 을 실행하도록 할 수 있다. 

예로 다음과 같은 SQL 문을 보자.

```sql
SELECT * FROM 거래
WHERE :cust_id is null 
AND 거래일자 between :dt1 and :dt2
UNION ALL 
SELECT * FROM 거래
WHERE :cust is not null 
AND 고객ID = :cust_id
AND 거래일자 between :dt1 and :dt2
```  

이 방법을 사용하면 :cust_id 값의 존재 여부에 따라서 최적의 SQL 문을 사용하도록 할 수 있다. 

단점으로 SQL 문이 길어진다는 점이 있다. 



 
