# 인덱스 튜닝 

***

## 목차 

- 테이블 엑세스 최소화

***

## 1. 테이블 엑세스 최소화 

본 절에서는 테이블 랜덤 엑세스를 최소화하는 구체적인 방법들을 소개하겠다. 

그전에 앞서 테이블 랜덤 엑세스가 성능에 미치는 영향을 알아보자. 

### 1.1 테이블 랜덤 엑세스 

대량의 데이터가 있어도 인덱스를 이용하면 엄청 빠르게 조회하는게 가능하다. 

하지만 대량의 데이터를 조회할 때 인덱스를 이용하면 테이블 풀 스캔보다 느리기도 하다. 

인덱스로 검색하는데 느리다는게 이해가 안될 수도 있다. 이 이유들에 대해서 알아보자. 

#### 인덱스 ROWID 는 물리적 주소? 논리적 주소? 

실행 계획을 보면 `TABLE ACCESS BY INDEX ROWID` 라는 걸 볼 수 있다. 

이 계획은 인덱스를 이용해서 테이블에 엑세스 하겠다는 것이다. SQL 이 참조하는 모든 칼럼이 인덱스에 있지 않으면 인덱스에 있는 ROWID 를 바탕으로
실제 테이블에 엑세스 한다. 
 
ROWID 에 들어가는 값은 데이터 파일 번호, 오브젝트 번호, 블록 번호와 같이 데이터를 찾기 위한 값이 들어가 있다.

그래서 물리적 주소라고 생각할 수 있지만 ROWID 는 논리적 주소다. 도서에 있는 페이지 처럼 논리적 주소에 해당한다. 

ROWID 는 포인터 같은 개념보다는 디스크 상에서 테이블 레코드를 찾아가기 위한 논리적 주소에 해당한다.

#### 메인 메모리 DB 와의 비교 

잘 튜닝된 OLTP 상에서 데이터 캐시율은 99%에 해당한다고 한다. 

하지만 모든 데이터를 메모리에 올리는 메인 메모리 DB 와 성능을 비교하면 차이가 좀 난다. 왜그럴까? 

메인 메모리에 저장된 데이터는 메모리 상의 주소정보를 저장하는 즉 포인터와 같은 역할을 하기 때문에 접근성이 뛰어나다.

하지만 오라클과 같은 데이터베이스는 테이블 블록이 버퍼 캐시에 저장되더라도 밀려났다가 다시 캐싱되는 일이 일너날 수 있다. 그때마다 
다른 공간에 캐싱될 수 있기 때문에 포인터처럼 사용하는게 불가능하다. 

즉 메모리 주소 정보를 이용하는게 아니라 디스크 주소 정보가 기반이기 때문에 포인터 처럼 사용하는게 불가능하다.

데이터베이스는 디스크 주소 정보를 기반으로 해시값을 얻어서 그 값을 기반으로 버퍼 캐시에 저장한다. 

#### I/O 메커니즘 복습

DBA (데이터 파일 번호 + 블록 번호) 는 디스크 상에서 블록을 찾기 위한 정보다. 

그렇다고 해서 매번 디스크에서 읽으면 성능이 오르지 않기 떄문에 버퍼 케시에서 읽을려고 한다. 

그래서 읽기 전에는 항상 버퍼 캐시에 존재하는지 먼저 확인한다. 

이는 읽고자 하는 DBA 를 해시 함수에 입력해서 해시체인을 찾고 거기서 버퍼 헤드를 찾는다. 

캐시에 적재할 때와 읽을 때 같은 해시 함수를 사용하므로 버퍼 헤더를 매번 일정한 값이 잡히지만 실제 데이터가 담긴 버퍼 블록은
매번 다른 위치에 캐싱되는데 그 메모리 주소 값을 버퍼 헤더가 가지고 있다. 

즉 버퍼 헤더가 포인터와 같은 역할을 한다. 

이처럼 인덱스를 통해 테이블 블록을 읽을 때는 리프 블록에서 읽은 ROWID 를 바탕으로 DBA 정보를 얻어서 버퍼 캐시나
디스크에서 조회를 하고

테이블 풀 스캔을 할 떈 익스텐트 맵을 읽어서 익스텐트 리스트를 가지고오고 거기에 있는 첫번째 블록의 주소부터 끝까지 읽는 방식을 사용한다. 

### 1.2 인덱스 클러스터링 팩터 

클러스터링 팩터 (Clustering Factor) 는 군집성 계수라고도 불리며 특정 칼럼을 기준으로 같은 값을 가지는 데이터가 서로 모여있는 정도를 말한다. 

데이터가 물리적으로 모여있다면 데이터를 찾는 속도가 더 빠르다는 것이다. 

CF 가 높으면 인덱스에 있는 비슷한 값이 하나의 블록에 있다는 뜻으로 테이블 엑세스가 더 적을 수 있다. 

그리고 인덱스에서 레코드로 찾은 값이 결국에 테이블 엑세스 횟수가 같더라도 효과를 발휘할 수 있는데 

ROWID 로 테이블에 엑세스 할 때 항상 계산되는 해시 계산과 래치 획득을 안해도 되기 떄문이다. 이는 어렵게 찾아간 테이블 블록의 메모리 주소를
바로 해제하지 않고 일단 유지하기 때문이다. 이를 '버퍼 Pinning' 이라고 한다. 

즉 한 인덱스에서 테이블에 어렵게 접근했는데 다음 인덱스 레코드가 같은 테이블을 가리켰다면 해시 체인 스캔 과정과 래치 획득 없이 바로 테이블에 접근하는게 가능하다.

### 1.3 인덱스 손익 분기점

인덱스 ROWID 를 이용한 테이블 엑세스는 생각보다 비용이 크다. 

따라서 읽어야 할 데이터가 일정량을 넘는 순간 테이블 풀 스캔보다 오히려 느려지기 시작한다. 

Index Range Scan 이 Table Full Scan 보다 느려지기 시작하는 지점이 인덱스 손익 분기점이다.

Table Full Scan 은 데이터를 몇 건을 조회하던 성능이 느려지지 않는다. 

하지만 인덱스를 이용해 1만건을 조회한다면 거기 까지는 괜찮을 수 있겠지만 100만건이라면 완전 느려지기 시작할 것이다.

이는 모두 테이블 랜덤 엑세스가 지나치게 많아지기 때문이다. 

인덱스를 이용한 테이블 엑세스가 테이블 풀 스캔 보다 느려지게 만드는 가장 큰 요인은 다음과 같다. 

- Table Full Scan 은 시퀀셜 엑세스인 반면에 Index Range Scan 은 ROWID 를 이용한 랜덤 테이블 엑세스다. 

- Table Full Scan 은 Multiblock I/O 인 반면에 인덱스 ROWID 를 이용한 랜덤 테이블 엑세스는 Single Block I/O 이다. 

이런 인덱스의 손익 분기점은 전체 데이터에서 얼만큼을 가져오는지와 CF 에 따라서 달라진다. 

CF 가 나쁘면 5% 지점에서 인덱스 손익 분기점이 잡히고 보통의 경우에는 20% 정도로 잡힌다. 

#### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

온라인 프로그램은 보통 소량의 데이터를 읽고나서 갱신하는 일이 많으므로 인덱스가 효과적이다. 조인도 대부분 NL 을 사용하지만 괜찮다.

반면 대량 데이터를 읽고 갱신하는 배치 프로그램은 항상 전체 범위 기준으로 처리한다.

즉 처리하는 대상이 일부가 아니라 전체를 빠르게 보고 처리하는 걸 목표로 삼는다. 

이는 인덱스와 NL 조인 보다는 테이블 풀 스캔과 Hash Join 이 더 낫다. 

초대용량 테이블 같은 경우는 테이블 풀 스캔하면 이것도 엄청 느리기 때문에 이때는 파티션을 활용한 전략이 중요해진다. 

여기서 병렬 처리까지 할 수 있으면 더 대박이다.

그리고 파티션이 나눠지면 한 파티션에서 인덱스를 사용하는 것보다 효과가 좋지 않으므로 파티션이 나눠졌다면 테이블 풀 스캔을 적극적으로 
고려하는게 좋다. 

### 1.4 인덱스 칼럼 추가 

테이블 엑세스 최소화를 위해 가장 일반적으로 사용하는 기법은 인덱스에 칼럼을 추가하는 방법이다. 

이 방법은 인덱스에 적절한 칼럼을 추가해서 테이블 엑세스 횟수를 줄이는 방법이다.  

예시로 EMP 테이블에 (DEPTNO + JOB) 으로 인덱스가 걸려 있다고 생각해보자. 

SQL 문은 다음과 같다. 

```sql
SELECT *
FROM EMP
WHERE depno = 30
and sal >= 20
```

이 SQL 문에서는 depno 를 바탕으로 Range Scan 을 한 다음에 테이블에 각각 엑세스하면서 비교할 것이다.

만약 이 쿼리가 성능이 안나온다고 해서 인덱스 구성 자체를 (DEPTNO + SAL) 로 바꿀 순 없다. 

기존의 인덱스를 잘 사용하고 있는 쿼리가 있을 수 있기 때문이다. 

그렇다고 막 인덱스를 추가하면 인덱스 관리 비용과 DML 부하에 따른 트랜잭선 성능 저하가 생길 수 있다.

이 경우에 해결 방법으로 기존의 인덱스에 SAL 칼럼을 하나 붙이기만 해도 큰 효과를 누릴 수 있다. 

기존에는 DEPNO 가 맞다면 모두 테이블에 엑세스 했지만 SAL 칼럼을 바탕으로 조건에 해당하는 리프 블록에서만 테이블에 엑세스 하면 되므로
크게 테이블 엑세스 횟수를 줄일 수 있다. 

### 1.5 인덱스만 읽고 처리 

인덱스 칼럼을 추가해서 테이블 엑세스 횟수를 줄이는 방법에 대해서 알아봤다. 

이는 적절한 테이블에만 접근하도록 필터를 거는 역할을 하는 것이다.

하지만 필터의 역할이 필요없이 거의 다 테이블에 접근을 해야한다면 어떻게 해야할까? 별 효과가 없을 수 있다.

반드시 성능을 개선해야 한다면 쿼리에 사용하는 모든 칼럼을 인덱스에 사용해서 테이블 엑세스가 아예 발생하지 않도록 하는 방법이 있다. 

이 방법의 효과는 아주 좋지만 추가해야 할 칼럼이 많아서 실제로 적용하기 어려운 단점이 있다. 

#### Include 인덱스

오라클에는 아직 없지만 SQL Server 에는 들어온 유용한 기능으로 인덱스 키 외에 리프 노드에 칼럼을 함께 저장하는 방법이다.

인덱스를 생성할 때 아래와 같이 include 옵션으로 미리 칼럼을 지정하면 된다. 

```sql
create index emp_x01 on emp (deptno) include (sal)
``` 

include 옵션을 주고 생성한 EMP_X01 인덱스와 아래 EMP_X02 인덱스는 어떤 차이가 있을까?

```sql
create index emp_x02 on emp (deptno, sal)
```

EMP_X02 는 리프 노드 외에 브런치 노드와 루트 노드에도 sal 값을 저장한다. 둘 다 수직적 탐색에 사용할 수 있다는 특징이 있다.

하지만 EMP_X01 은 deptno 만이 수직적 탐색에 사용할 수 있다. 물론 수평적 탐색에는 SAL 을 사용하는게 가능하다.

아래 SQL 문을 처리할 땐 EMP_X01 과 EMP_X02 모두 커버링 인덱스다.

```sql
select sal 
from emp 
where deptno = 20 
```

또 아래 SQL 문을 처리할 때도 테이블 랜덤 엑세스 측면에서도 일량이 똑같다. 

두 인덱스 모두 불필요한 테이블 엑세스는 하지 않는다. 하지만 EMP_X01 가 좀 더 탐색하는 범위가 많을 수 있다. 아무래도 수직적 탐색이 좀 더 도와주기 때문이다. 

```sql
SELECT * 
FROM EMP 
WHERE deptno = 20 
and sal >= 2000
```

```sql
SELECT * 
FROM EMP 
WHERE deptno = 20 
and sal <= 2000
```

```sql
SELECT * 
FROM EMP 
WHERE deptno = 20 
and sal between 2000 and 3000
```

아래 SQL 문에서는 EMP_X02 에서는 소트 연산을 생략할 수 있지만 EMP_X01 에서는 그럴 수 없다. 

```sql
SELECT *
FROM EMP
WHERE deptno = 20
ORDER BY sal 
```

### 1.6 인덱스 구조 테이블 

인덱스를 이용한 테이블 엑세스가 고비용 구조이니 테이블 자체를 인덱스 구조로 생성하면 어떨까? 

실제로 그런 방법을 제공해주는데 오라클에서는 이를 IOT(Index-Oriented Table) 이라고 한다.

참고로 MS-SQL Server 에서는 Clustered Index 라고 한다.

테이블을 찾아가기 위한 ROWID 를 갖는 일반 인덱스와 달리 IOT 는 그 자리에 테이블 데이터를 가진다.

즉 IOT 는 인덱스 리프 블록이 테이블 데이터 그 자체다. 

테이블 인덱스 구조로 만드는 구문은 다음과 같다. 

```sql
create table index_org_t (a number, b varchar(10) constraint index_org_t_pk primary key (a))

organization index;
```

참고로 일반 테이블은 힙 구조라고 한다. 테이블을 생성할 때 대개 아래와 같이 생략되어 있다.

```sql
create table heap_org_t (a number, b varchar(10) constraint heap_org_t_pk primary key (a))

organization heap;
```

일반 힙 구조 테이블에 데이터를 입력할 땐 랜덤 방식을 이용한다. 

할당 받은 블록에 정해진 순서 없이 데이터를 입력하는 반면에 IOT 는 인덱스 구조 테이블이므로 정렬 상태를 유지하면서 데이터를 입력한다. 

IOT 는 인위적으로 클러스터링 팩터를 좋게 만드는 방법 중 하나로 같은 값을 가진 레코드들이 100% 로 정렬된 상태로 모여있어서 랜덤 엑세스가 아닌 
시퀀셜 방식으로 데이터를 엑세스한다.

이 떄문에 Between 이나 부등호 조건으로 읽을 때 유리하다.

 