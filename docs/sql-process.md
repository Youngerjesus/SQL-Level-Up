## SQL 처리 과정과 I/O

### SQL 공유 및 재사용 

#### 소프트 파싱(Soft Parsing) 과 하드 파싱(Hard Parsing) 

사용자가 전달한 SQL 문을 파서가 파싱한 후 옵티마이저가 최적의 실행 계획을 세운다.

하지만 미리 이전에 SQL 문에 대해서 옵티마이저가 실행 계획을 세운 적이 있다면 이는 라이브러리 캐시에 저장되어 있어서
그 정보를 가져와서 바로 실행계획에 사용한다. 이를 소프트 파싱이라고하며 매번 최적화 과정을 거치는 걸 하드 파싱이라고 한다.   

이 라이브러리 캐시를 통해서 매번 실행 계획을 세우지 않아도 된다. 

라이브러리 캐시를 사용할 때 주의할 점은 라이브러리 캐시에 값이 어떻게 저장되는 지를 이해하는게 중요한데 Key-Value 로
값이 저장된다고 할 때 SQL 문 그 자체로 값이 저장된다. 그러므로 동적 쿼리를 사용하는 경우 SQL 문 자체에 값을 바인딩 하지
않도록 한다. 바로 예시를 보면 이해하기가 쉽다.

##### Bad Case 

````java
String SQLStmt = "SELECT * FROM CUSTOME WHERE LOGIN_ID = '" + loginId + "'";
Statemet st = connection.createStatement();   
ResultSet rs = st.executeQuery(SQLStmt); 
````   

- 이렇게 쿼리를 짤 경우에 라이브러리 캐시에는 각 사용자마다 다른 로그인 아이디 값에 따라서 캐시에 저장될 것이다.

##### Good Case

````java
String SQLStmt = "SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?";
PreparedStatement st = connection.prepareStatement(SQLStmt); 
st.setString(1, loginId); 
```` 

### 데이터 저장 구조 및 I/O 메커니즘 

#### SQL 이 느린 이유

SQL 이 느린 이유는 대부분 I/O 작업 떄문이다. 프로세스는 I/O 를 하는 동안 Waiting 상태로 돌아가며 CPU 를
받지 않고 I/O 작업이 완료되면 그제서야 다시 일을 재개하기 때문이다. 

그러므로 I/O 메커니즘 자체가 성능을 느리게 하는 이유가 된다. 

#### 데이터베이스 저장 구조

데이터베이스를 저장하기 위해서는 테이블 스페이스를 만들어야 하고 테이블 스페이스 안에는 여러개의 데이터 파일(세그먼트) 로
구성된다.

세그먼트는 테이블, 인덱스, 파티션, Lob 으로 구성된다. 저장공간을 가지는 개념이 세그먼트라고 생각하면 된다. 

파티션 구조가 아니라면 테이블도 하나의 세그먼트고 인덱스도 하나의 세그먼트다. 파티션 구조라면 한 테이블의 데이터가 여러 세그먼트에 나뉠 수 있다. 

Lob 칼럼은 그 자체가 하나의 세그먼트로 구성되고 자신이 속한 테이블과 다른 별도 공간에 값을 저장한다. 

하나의 세그먼트 안에는 여러가지의 익스텐드(Extend) 로 구성된다.

익스텐드는 공간 확장의 구성단위로 사용된다. 테이블이나 데이터를 입력하다가 공간이 부족하다면 익스텐트를 추가로 테이블 스페이스로부터 받아서 저장된다. 데이터를 더 넣고 싶다면 익스텐드를 늘리는 구조다.

익스텐트를 확장하는 구조지만 실제로 사용자의 데이터는 블록에 저장된다. 

그리고 익스텐드 하나에 여러개의 데이터 블록이 연속적으로 들어가있고 하나의 익스텐트는 하나의 테이블을 가리키며 이 데이터 블록에 실질적인 데이터(테이블 로우 같은 정보)가 들어간다.

세그먼트는 익스텐트와는 다르게 할당된 익스텐트는 같은 데이터파일이 아닐 수 있다. 오히려 아닐 가능성이 높다.

익스텐트안의 블록은 연속된 공간이지만 익스텐트끼리는 연속된 공간이 아니다.  

데이터베이스에서 I/O 의 기준은 블록 단위이므로 특정 레코드만 필요해도 블록 단위로 데이터를 가지고온다.

모든 데이터블록은 디스크 상에서 몇 번 데이터 파일의 몇번째 블록인지를 나타내는 자신의 고유 값을 가진다.

오라클 기준으로 각 세그먼트 마다 익스텐트 맵을 가지고 있고 이 익스텐트 맵에는 익스텐트 목록을 가지고 있고 
이 익스텐트는 첫번째 데이터 블록의 주소를 가지고 있다. 이를 이용하면 익스텐트 리스트를 가지고오고 익스텐트 첫번째
블록부터 계속해서 읽으면 되므로 전체 데이터 블록을 읽을 수 있고 이것이 테이블 풀 스캔이다. (이 정보를 봤을 때 한 세그먼트에는 다른 테이블의 정보가 있으면 테이블 풀 스캔이 불가능 하다곳 생각한다.
즉 한 세그먼트에는 한 종류의 정보만 있고 여러개의 데이터 파일이 있다고 생각한다.)

인덱스 같은 경우는 리프노드에 있는 ROWID 를 기준으로 데이터 블록을 찾는데 이는 데이터 파일의 ID + 블록의 순번 을 통해서
찾는다. 
 
#### 버퍼 캐시 

데이터베이스에는 라이브러리 캐시 말고도 버퍼 캐시라고 데이터 블록 자체를 메모리에 저장해두는 버퍼 캐시가 있다.
 
내가 만약에 찾아야 하는 데이터 블록이 버퍼 캐시에 있다면 디스크에 I/O 하지 않고 바로 버퍼캐시를 이용한다. 

그러므로 버퍼 캐시에 없다면 디스크에 I/O 를 하므로 이 디스크에 I/O 를 줄이긴 위해서는 버퍼캐시의 I/O 를 줄여야한다. 

그러므로 항상 데이터를 가지고 올 때 참조해야하는 데이터 블록의 개수가 몇 개 인지를 예측하며 고려해야 하는게 중요하고 
SQL 튜닝은 대부분 이를 다룬다. 

이외에도 Single Block I/O 를 사용할지 Multi Block I/O 를 사용할지 이런 요소를 고려하면서 쿼리를 짜면 된다. 

인덱스를 이용할 땐 기본적으로 Single Block I/O 를 사용한다.

- 인덱스 루트 블록을 읽을 때

- 인덱스 브랜치 블록을 읽을 때

- 인덱스 리프 브록을 읽을 때

- 인덱스 리프 블록에 있는 값을 이용해 테이블 블록을 읽을 때 

테이블 풀 스캔을 할 땐 Multi Block I/O 를 사용한다. Multi Block I/O 는 인접한 데이터 블록을 한번에
가져와서 적재하는 방식을 이용한다. 이 인접한 데이터 블록은 익스텐트를 기준으로 잡힌다.
하나의 익스텐트에 20개의 블록이 들어오고 한번에 가져올 수 있는 Multi Block 의 개수가 8 로 설정되어 있다면
8, 8, 4 이렇게 가지고 온다. 

이를 이해하면 인덱스를 통한 검색이 빠르지 않은 경우도 있다는 걸 이해할 수 있다. Index Range Scan 을 한다고
생각해보면 인덱스가 검색해야 하는 데이터 블록의 수가 많다면 하나하나씩 I/O 를 하므로 테이블 풀 스캔보다 느릴 확률이 높다.
그러므로 인덱스는 하나의 데이터 블록을 가지고 처리할 수 있을 때 사용하는 것이 가장 좋다고 생각한다. 

  


   
 
    

