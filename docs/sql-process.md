## SQL 처리 과정과 I/O

### SQL 공유 및 재사용 

#### 소프트 파싱(Soft Parsing) 과 하드 파싱(Hard Parsing) 

사용자가 전달한 SQL 문을 파서가 파싱한 후 옵티마이저가 최적의 실행 계획을 세운다.

하지만 미리 이전에 SQL 문에 대해서 옵티마이저가 실행 계획을 세운 적이 있다면 이는 라이브러리 캐시에 저장되어 있어서
그 정보를 가져와서 바로 실행계획에 사용한다. 이를 소프트 파싱이라고하며 매번 최적화 과정을 거치는 걸 하드 파싱이라고 한다.   

이 라이브러리 캐시를 통해서 매번 실행 계획을 세우지 않아도 된다. 

라이브러리 캐시를 사용할 때 주의할 점은 라이브러리 캐시에 값이 어떻게 저장되는 지를 이해하는게 중요한데 Key-Value 로
값이 저장된다고 할 때 SQL 문 그 자체로 값이 저장된다. 그러므로 동적 쿼리를 사용하는 경우 SQL 문 자체에 값을 바인딩 하지
않도록 한다. 바로 예시를 보면 이해하기가 쉽다.

##### Bad Case 

````java
String SQLStmt = "SELECT * FROM CUSTOME WHERE LOGIN_ID = '" + loginId + "'";
Statemet st = connection.createStatement();   
ResultSet rs = st.executeQuery(SQLStmt); 
````   

- 이렇게 쿼리를 짤 경우에 라이브러리 캐시에는 각 사용자마다 다른 로그인 아이디 값에 따라서 캐시에 저장될 것이다.

##### Good Case

````java
String SQLStmt = "SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?";
PreparedStatement st = connection.prepareStatement(SQLStmt); 
st.setString(1, loginId); 
```` 

### 데이터 저장 구조 및 I/O 메커니즘 

#### SQL 이 느린 이유

SQL 이 느린 이유는 대부분 I/O 작업 떄문이다. 프로세스는 I/O 를 하는 동안 Waiting 상태로 돌아가며 CPU 를
받지 않고 I/O 작업이 완료되면 그제서야 다시 일을 재개하기 때문이다. 

그러므로 I/O 메커니즘 자체가 성능을 느리게 하는 이유가 된다. 

#### 데이터베이스 저장 구조

데이터베이스를 저장하기 위해서는 테이블 스페이스를 만들어야 하고 테이블 스페이스 안에는 여러개의 데이터 파일(세그먼트) 로
구성된다. 

데이터 파일(세그먼트)는 테이블이나 인덱스 처럼 데이터를 필요로하는 오브젝트다. 

하나의 세그먼트 안에는 여러가지의 익스텐드(Extend) 로 구성된다. 

익스텐드는 공간 확장의 구성단위로 사용된다. 데이터를 더 넣고 싶다면 익스텐드를 늘리는 구조다.

익스텐드 하나에 여러개의 데이터 블록이 들어가있고 이 데이터 블록에 실질적인 데이터(테이블 로우 같은 정보)가 들어간다. 

데이터베이스에서 I/O 의 기준은 블록 단위이므로 특정 레코드만 필요해도 블록 단위로 데이터를 가지고온다. 

오라클 기준으로 각 세그먼트 마다 익스텐트 맵을 가지고 있고 이 익스텐트 맵에는 익스텐트 목록을 가지고 있고 
이 익스텐트는 첫번째 데이터 블록의 주소를 가지고 있다. 이를 이용하면 익스텐트 리스트를 가지고오고 익스텐트 첫번째
블록부터 계속해서 읽으면 되므로 전체 데이터 블록을 읽을 수 있고 이것이 테이블 풀 스캔이다. 

인덱스 같은 경우는 리프노드에 있는 ROWID 를 기준으로 데이터 블록을 찾는데 이는 데이터 파일의 ID + 블록의 순번 을 통해서
찾는다. 
 
#### 버퍼 캐시 

데이터베이스에는 라이브러리 캐시 말고도 버퍼 캐시라고 데이터 블록 자체를 메모리에 저장해두는 버퍼 캐시가 있다.
 
내가 만약에 찾아야 하는 데이터 블록이 버퍼 캐시에 있다면 디스크에 I/O 하지 않고 바로 버퍼캐시를 이용한다. 

그러므로 버퍼 캐시에 없다면 디스크에 I/O 를 하므로 이 디스크에 I/O 를 줄이긴 위해서는 버퍼캐시의 I/O 를 줄여야한다. 

그러므로 항상 데이터를 가지고 올 때 참조해야하는 데이터 블록의 개수가 몇 개 인지를 예측하며 고려해야 하는게 중요하고 
SQL 튜닝은 대부분 이를 다룬다. 

이외에도 Single Block I/O 를 사용할지 Multi Block I/O 를 사용할지 이런 요소를 고려하면서 쿼리를 짜면 된다. 

인덱스를 이용할 땐 기본적으로 Single Block I/O 를 사용한다.

- 인덱스 루트 블록을 읽을 때

- 인덱스 브랜치 블록을 읽을 때

- 인덱스 리프 브록을 읽을 때

- 인덱스 리프 블록에 있는 값을 이용해 테이블 블록을 읽을 때 

테이블 풀 스캔을 할 땐 Multi Block I/O 를 사용한다. Multi Block I/O 는 인접한 데이터 블록을 한번에
가져와서 적재하는 방식을 이용한다. 이 인접한 데이터 블록은 익스텐트를 기준으로 잡힌다.
하나의 익스텐트에 20개의 블록이 들어오고 한번에 가져올 수 있는 Multi Block 의 개수가 8 로 설정되어 있다면
8, 8, 4 이렇게 가지고 온다. 

이를 이해하면 인덱스를 통한 검색이 빠르지 않은 경우도 있다는 걸 이해할 수 있다. Index Range Scan 을 한다고
생각해보면 인덱스가 검색해야 하는 데이터 블록의 수가 많다면 하나하나씩 I/O 를 하므로 테이블 풀 스캔보다 느릴 확률이 높다.
그러므로 인덱스는 하나의 데이터 블록을 가지고 처리할 수 있을 때 사용하는 것이 가장 좋다고 생각한다. 

  


   
 
    

