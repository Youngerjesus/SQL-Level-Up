## 해시 조인

NL 조인은 인덱스를 이용한 조인 방식이므로 인덱스 구성에 따른 성능차이가 심하다. 

인덱스를 아무리 완벽하게 구성해도 많은 데이터를 조인하면 버퍼 캐시에서 미스가 나므로 랜덤 I/O 가 발생해 성능이 나오지 않는다. 

하지만 소트 머지 조인(Sort Merge Join) 과 해시 조인(Hash Join) 은 인덱스를 이용한 테이블 랜덤 엑세스를 하지 않으므로 대량의 데이터를 조인할 때 성능이 잘 나오게 된다. 그렇다고 이러한 조인이 항상 우위에 있는 것은 아니다. 각각의 목적에 맞는 조인 방식을 사용할 수 있어야 한다. 
 
***

### 1. 기본 메커니즘

해시 조인도 소트 머지 조인과 같은 두 가지 단계로 진행된다. 

1. Build 단계: 작은 쪽 테이블(Build Input) 을 읽어서 해시 테이블을 생성한다. 해시 테이블은 PGA (Process Global Area) 에서 생성되며 다른 프로세스는 접근 할 수 없다. 

2. Probe 단계: 큰 쪽 테이블(Probe Input) 을 읽으면서 조인 칼럼을 기준으로 해시 테이블을 탐색하면서 조인한다. 

조인 튜닝에서 사용한 예제를 가지고 위 단계를 이해해보자. 

```sql
SELECT /*+ ordered use_hash(c) */ 
    e.사원명, e.사원번호, e.입사일자 
    c.고객명, c.전화번호, c.최종주문금액
FROM 사원 e, 고객 c 
WHERE e.입사일자 >= '19960101'
AND c.관리사원번호 = e.사원번호 
AND e.부서코드 = '2123'
AND c.최종주문금액 >= 20000
```

여기서는 use_hash 힌트를 통해 사원 테이블을 가지고 고객 테이블과 조인을 할 때 해시 조인을 이용하라고 명시적으로 얘기했다. 

1. Build 단계: 사원 테이블에 있는 데이터를 읽어서 해시 테이블을 생성한다. 이때 키 값은 사원 테이블과 고객 테이블의 조인 칼럼인 사원 번호를 가지고 해시 테이블 키 값으로 이용한다.

2. Probe 단계: 고객 조건에 맞는 데이터를 하나하나 읽으면서 '관리사원번호' 칼럼을 통해서 해시 테이블을 스캔한다. 

***

### 2. 해시 조인이 빠른 이유 

Hash Area 에 생성한 해시 테이블을 이용한다는 점만 다를 뿐 해시 조인도 조인 프로세싱 자체는 NL 조인과 다르다.

그런데도 해시 조인이 NL 조인보다 빠른 이유는 해시 테이블을 PGA 영역에 할당하므로 NL 조인 방식인 인덱스 탐색 후 랜덤 테이블에 엑세스 하기 위해 래치 획득이나 버퍼 캐시를 경유하지 않아도 되므로 빠르다.

즉 NL 조인은 Outer 테이블 레코드마다 Inner 쪽 테이블에 엑세스 하기 위해 래치 획득 및 캐시 버퍼 스캔 과정을 반복하지만 해시 조인은 PGA 영역에 해시 테이블이 올라가 있으므로 빠르게 데이터를 탐색하고 조인할 수 있다.    

해시 조인과 소트 머지 조인을 비교해보자면 둘 다 오퍼레이션을 위해 PGA 영역에 저장한다는 점은 같지만 소트 머지 조인은 두 테이블 모두를 PGA 영역에 정렬된 상태로 만들지만 해시 조인은 두 테이블 중 데이터가 더 작은쪽을 PGA 영역에 저장한다. 

그러므로 데이터 저장량 자체가 소트 머지 조인이 더 많고 PGA 영역 같은 경우는 다 차면 Temp 스페이스라는 디스크에 저장을 하게 되는데 디스크에 엑세스 하기 떄문에 더 느려질 가능성도 있다. 그리고 정렬하는 비용은 O(N * log N) 인데 비해서 해시 테이블을 만드는 시간 복잡도는 O(N) 이다.

그리고 해시 조인 같은 경우 해시 테이블의 크기가 PGA 영역을 초과해 Temp 스페이스를 쓰더라도 대용량 데이터 조인이면 다른 조인 보다 빠르다. 

### 3. 대용량 Build Input 처리 

만약 조인을 하는 두 테이블이 둘 다 대용량이라서 인메모리 해시 조인이 불가능한 상황이라면 어떻게 할까? 

복잡할 것 같지만 의외로 간단하다. 두 단계로 나눠서 정복하면 된다. 분할 * 정복 (Divided Conquer) 방식이다. 

대용량 데이터를 파티션으로 분할한 다음 파티션 별로 조인을 하는 방식인데 구체적인 방법은 다음과 같다. 

1. 파티션 단계  

- 조인하는 양쪽 테이블을 조인 칼럼을 기준으로 파티션 별로 나눈다. 이를 통해 같은 조인 칼럼을 가지는 데이터는 파티션 별로 Pair 를 이루게 되고 대용량 해시 테이블이 필요한게 아닌 가능성 있는 데이터만 해시 테이블로 만들게 된다. 

- 이 방식은 반환된 해시 값에 따라서 동적으로 파티셔닝 되고 독립적으로 처리할 수 있는 여러 개의 작은 서브 집합으로 분리되는 단계다. 양쪽 집합 모두 읽으므로 디스크 Temp 공간에 저장될 가능성이 높으니 인메모리 해시 조인보다는 느릴 수 있다.   

2. 조인 단계 

- 파티션 단계를 완료하면 각 파티션 Pair 에 대해서 하나씩 조인을 수행한다. 이때 각각의 Pair 에서 데이터가 작은 쪽을 Build Input 으로 사용한다.

- 모든 파티션 짝에 대해 처리를 마칠때까지 이 과정을 반복한다. 

### 4. 해시 조인 실행계획 제어 

아래는 해시 조인 실행 계획이다. 실행 계획에 있는 Hash Join 바로 아래 사원 테이블을 가지고 해시 테이블을 생성하고 고객 테이블을 읽으면서 조인하는 과정이라고 생각하면 된다. 

```text
Execution Plan
----------------------------------------------------
HASH JOIN
    TABLE ACCESS BY INDEX ROWID OF '사원' (TABLE)
        INDEX RANGE SCAN OF '사원_X1' (INDEX)
    TABLE ACCESS BY INDEX ROWID OF '고객' (TABLE)
        INDEX RANGE SCAN OF '고객_X1' (INDEX) 
```

해시 조인을 하고 싶다면 이전과 같이 use_hash 를 사용하면 된다.

```sql
SELECT /*+ use_hash(e c) */ 
    e.사원명, e.사원번호, e.입사일자 
    c.고객명, c.전화번호, c.최종주문금액
FROM 사원 e, 고객 c 
WHERE e.입사일자 >= '19960101'
AND c.관리사원번호 = e.사원번호 
AND e.부서코드 = '2123'
AND c.최종주문금액 >= 20000
``` 

use_hash 만 사용할 경우 Build Input 은 옵티마이저가 선택하게 되는데 이걸 원하지 않는다면 leading 이나 ordered 힌트를 사용하면 된다. 그러면 이 순서를 따른다. 

아니면 swap_join_inputs 힌트로 명시적으로 Build Input 을 선택하도록 할 수도 있다. 

그리고 여러 개의 해시 조인을 하게 된다면 이 테이블을 명시적으로 해시 테이블로 사용하지 않도록 할 필요가 있는데 이는 no_swap_join_inputs() 을 사용하면 된다.

***

### 5. 조인 메소드 선택 기준

지금까지 설명한 해시 조인의 경우 워낙 성능이 좋다보니 내부 원리를 모르고 그냥 이걸 디폴트로 사용하는 개발자가 많다. 이걸 사용하면 인덱스 설계를 따르지 않아도 되니까.

그런데 이는 매우 위험한 생각인데 수행 빈도가 높은 SQL 인 경우에는 해시 조인을 사용하지 않는 편이 낫다. 

이유는 뒤에서 설명하고 일단 조인 메소드 선택 기준을 보면 다음과 같다.

- 소량 데이터를 조인한다 -> NL 조인

- 대량 데이터를 조인한다. -> 해시 조인

-> 대량 데이터를 조인하지만 '=' 같은 등치 조건이 아니라 범위 조건이나 검색이 필요한 경우 -> 소트 머지 조인

여기서 소량과 대량 데이터의 기준은 단순히 데이터량이 많고 적음이 아니라 최적화를 했는데도 테이블 랜덤 엑세스가 많아서 성능이 나오지 않는 경우를 말한다. 

수행 빈도가 높은 쿼리에 대해서 선택 기준은 다음과 같다.

- NL 조인과 해시 조인이 성능이 비슷하거나 해시 조인 성능이 약간 더 높을 때 -> NL 조인

- 해시 조인 성능이 월등히 뛰어날 때 -> 해시 조인 

왜 NL 조인이 우선적으로 고려되야 할까? NL 조인 같은 경우는 인덱스 설계 같은 작업이 필요함에도 불구하고 조인을 위한 인덱스 블록을 재사용 할 수 있다는 특징 떄문에 선호된다.

해시 조인과 소트 머지 조인은 해당 쿼리의 조인만을 위해서 해시 테이블이나 정렬된 테이블을 만들고 쿼리가 끝나면 폐기된다. 그러므로 한 쿼리에만 적합하다는 특징이 있다. 또 이러한 사전 준비 작업을 하기위해 PGA 라는 추가적인 메모리 공간을 사용하기도 하고 CPU 를 사용하기도 한다. 

이러한 정보를 비교해서 해시 조인은 아래와 같은 조건일 때 사용하자. 

- 수행 빈도가 낮은 SQL 문을 사용할 때

- 쿼리 시간이 오래걸리거나, 대규모 데이터를 조인할 때 

이러한 조건은 배치 프로그램 쿼리 특성이기도 하다.  